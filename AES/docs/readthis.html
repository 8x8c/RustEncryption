<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AES - README</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
    pre { background-color: #f4f4f4; padding: 10px; border-radius: 4px; overflow: auto; }
    code { font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; }
    h1, h2, h3 { color: #333; }
    ul { margin-left: 20px; }
  </style>
</head>
<body>
  <h1>AES</h1>
  <p>
    The AES is a command-line interface (CLI) tool built with Rust that securely encrypts and decrypts files. 
    It leverages modern, well‑vetted cryptographic primitives to ensure both the confidentiality and integrity of your data.
  </p>

  <h2>Overview</h2>
  <p>
    This application is designed with robust security in mind. It employs a two-pronged approach:
  </p>
  <ul>
    <li>
      <strong>Password-Based Key Derivation:</strong> Uses Argon2id to convert a user-supplied password into a strong 256‑bit key. 
      The Argon2id parameters (memory cost, time cost, parallelism) are set to resist brute-force attacks.
    </li>
    <li>
      <strong>Authenticated Encryption:</strong> Utilizes AES‑256‑GCM for encryption. This algorithm not only encrypts your data but also verifies its integrity, 
      ensuring that any unauthorized modifications are detected during decryption.
    </li>
  </ul>

  <h2>File Format</h2>
  <p>
    The encrypted file generated by the tool is self-contained. It comprises:
  </p>
  <ul>
    <li>
      <strong>Magic Header:</strong> A fixed string ("SECUREENC") that identifies the file as being encrypted with this tool.
    </li>
    <li>
      <strong>Salt:</strong> A 16-byte random value used in the Argon2id key derivation process.
    </li>
    <li>
      <strong>Nonce:</strong> A 12-byte random value required by AES‑256‑GCM.
    </li>
    <li>
      <strong>Ciphertext:</strong> The actual encrypted data.
    </li>
  </ul>

  <h2>Encryption Flow</h2>
  <ol>
    <li>
      <strong>Input Reading:</strong> The app reads the entire input file into memory.
    </li>
    <li>
      <strong>Salt and Nonce Generation:</strong> It generates a random 16-byte salt and a 12-byte nonce using a cryptographically secure random number generator.
    </li>
    <li>
      <strong>Key Derivation:</strong> The user-provided password and generated salt are fed into the Argon2id algorithm (with a 64 MB memory cost, 3 iterations, and 4 lanes) to derive a 256-bit key.
    </li>
    <li>
      <strong>Encryption:</strong> The plaintext file data is encrypted with AES‑256‑GCM, producing ciphertext that is authenticated, meaning any tampering is detectable.
    </li>
    <li>
      <strong>Output:</strong> The output file is written with the magic header, followed by the salt, nonce, and the ciphertext.
    </li>
  </ol>

  <h2>Decryption Flow</h2>
  <ol>
    <li>
      <strong>Header Verification:</strong> The app reads the encrypted file, checks the magic header, and confirms that it is in the expected format.
    </li>
    <li>
      <strong>Extraction:</strong> It extracts the salt and nonce embedded in the file.
    </li>
    <li>
      <strong>Key Re-Derivation:</strong> Using the same Argon2id parameters and the provided password, the key is re-derived.
    </li>
    <li>
      <strong>Decryption and Authentication:</strong> AES‑256‑GCM decrypts the ciphertext. If the authentication fails (due to an incorrect password or data tampering), the decryption process returns an error.
    </li>
    <li>
      <strong>Output:</strong> The decrypted file is then written to the specified output location.
    </li>
  </ol>

  <h2>Security Considerations</h2>
  <ul>
    <li>
      <strong>Password Handling:</strong> In production environments, avoid passing passwords as command-line arguments. Instead, consider using secure input methods (e.g., password prompts using crates like <code>rpassword</code>).
    </li>
    <li>
      <strong>Memory Management:</strong> Currently, the entire file is loaded into memory. For very large files, a streaming approach should be considered.
    </li>
    <li>
      <strong>Zeroing Sensitive Data:</strong> To further secure the application, consider zeroing out sensitive information (such as the derived key) from memory as soon as it is no longer needed. Libraries like <code>zeroize</code> can be used for this purpose.
    </li>
  </ul>

  <h2>Project Structure</h2>
  <p>The project is organized into two main files:</p>
  <ul>
    <li>
      <strong>Cargo.toml:</strong> Defines the project metadata and dependencies:
      <pre><code>[package]
name = "AES"
version = "1.0.0"
edition = "2021"

[dependencies]
clap = { version = "4", features = ["derive"] }
rand = "0.8"
aes-gcm = "0.10"
argon2 = "0.4"
      </code></pre>
    </li>
    <li>
      <strong>src/main.rs:</strong> Contains the CLI logic, encryption and decryption functions, and file handling.
      <pre><code>use std::fs;
use std::io::{Read, Write};
use clap::{Arg, Command};
use rand::RngCore;
use aes_gcm::aead::{Aead, NewAead, generic_array::GenericArray};
use aes_gcm::Aes256Gcm;
use argon2::{self, Config, Variant, ThreadMode};

fn main() -> Result&lt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let matches = Command::new("secure-file-encryptor")
        .version("1.0")
        .about("Encrypts and decrypts files securely using AES-256-GCM and Argon2id")
        .subcommand_required(true)
        .subcommand(
            Command::new("encrypt")
                .about("Encrypts a file")
                .arg(Arg::new("input")
                     .short('i')
                     .long("input")
                     .required(true)
                     .takes_value(true)
                     .help("Path to the input file"))
                .arg(Arg::new("output")
                     .short('o')
                     .long("output")
                     .required(true)
                     .takes_value(true)
                     .help("Path to the output (encrypted) file"))
                .arg(Arg::new("password")
                     .short('p')
                     .long("password")
                     .required(true)
                     .takes_value(true)
                     .help("Password for encryption"))
        )
        .subcommand(
            Command::new("decrypt")
                .about("Decrypts a file")
                .arg(Arg::new("input")
                     .short('i')
                     .long("input")
                     .required(true)
                     .takes_value(true)
                     .help("Path to the input (encrypted) file"))
                .arg(Arg::new("output")
                     .short('o')
                     .long("output")
                     .required(true)
                     .takes_value(true)
                     .help("Path to the output (decrypted) file"))
                .arg(Arg::new("password")
                     .short('p')
                     .long("password")
                     .required(true)
                     .takes_value(true)
                     .help("Password for decryption"))
        )
        .get_matches();

    match matches.subcommand() {
        Some(("encrypt", sub_m)) => {
            let input_path = sub_m.get_one::<String>("input").unwrap();
            let output_path = sub_m.get_one::<String>("output").unwrap();
            let password = sub_m.get_one::<String>("password").unwrap();

            // Read the entire input file into memory.
            let plaintext = fs::read(input_path)?;

            // Generate random salt and nonce
            let mut salt = [0u8; 16];
            rand::thread_rng().fill_bytes(&mut salt);
            let mut nonce = [0u8; 12];
            rand::thread_rng().fill_bytes(&mut nonce);

            // Configure Argon2id with strong security parameters
            let config = Config {
                variant: Variant::Argon2id,
                mem_cost: 65536,
                time_cost: 3,
                lanes: 4,
                thread_mode: ThreadMode::Parallel,
                secret: &[],
                ad: &[],
                hash_length: 32,
                ..Default::default()
            };

            // Derive a key from the password and salt
            let key = argon2::hash_raw(password.as_bytes(), &salt, &config)?;
            if key.len() != 32 {
                return Err("Derived key length is not 32 bytes".into());
            }
            let key = GenericArray::clone_from_slice(&key);

            // Encrypt using AES-256-GCM
            let cipher = Aes256Gcm::new(&key);
            let ciphertext = cipher.encrypt(GenericArray::from_slice(&nonce), plaintext.as_ref())
                .map_err(|_| "Encryption failed")?;

            // Write output file: magic header, salt, nonce, then ciphertext.
            let mut out_file = fs::File::create(output_path)?;
            out_file.write_all(b"SECUREENC")?;
            out_file.write_all(&salt)?;
            out_file.write_all(&nonce)?;
            out_file.write_all(&ciphertext)?;
        },
        Some(("decrypt", sub_m)) => {
            let input_path = sub_m.get_one::<String>("input").unwrap();
            let output_path = sub_m.get_one::<String>("output").unwrap();
            let password = sub_m.get_one::<String>("password").unwrap();

            // Open the encrypted file
            let mut file = fs::File::open(input_path)?;
            let mut header = [0u8; 9];
            file.read_exact(&mut header)?;
            if &header != b"SECUREENC" {
                return Err("Invalid file header. This file may not be encrypted with this tool.".into());
            }

            // Read salt and nonce from the file
            let mut salt = [0u8; 16];
            file.read_exact(&mut salt)?;
            let mut nonce = [0u8; 12];
            file.read_exact(&mut nonce)?;
            let mut ciphertext = Vec::new();
            file.read_to_end(&mut ciphertext)?;

            // Recreate Argon2id configuration
            let config = Config {
                variant: Variant::Argon2id,
                mem_cost: 65536,
                time_cost: 3,
                lanes: 4,
                thread_mode: ThreadMode::Parallel,
                secret: &[],
                ad: &[],
                hash_length: 32,
                ..Default::default()
            };

            let key = argon2::hash_raw(password.as_bytes(), &salt, &config)?;
            if key.len() != 32 {
                return Err("Derived key length is not 32 bytes".into());
            }
            let key = GenericArray::clone_from_slice(&key);
            let cipher = Aes256Gcm::new(&key);

            // Attempt decryption
            let plaintext = cipher.decrypt(GenericArray::from_slice(&nonce), ciphertext.as_ref())
                .map_err(|_| "Decryption failed. Incorrect password or data is corrupted.")?;
            fs::write(output_path, plaintext)?;
        },
        _ => unreachable!(),
    }

    Ok(())
}
      </code></pre>
    </li>
  </ul>

  <h2>Installation and Usage</h2>
  <h3>Installation</h3>
  <p>
    Ensure you have Rust and Cargo installed. Then, build the application with:
  </p>
  <pre><code>cargo build --release</code></pre>
  <h3>Usage</h3>
  <p>
    The tool supports two commands: <code>encrypt</code> and <code>decrypt</code>.
  </p>
  <p><strong>Encryption Example:</strong></p>
  <pre><code>cargo run -- encrypt -i secret.txt -o secret.enc -p "YourStrongPassword"</code></pre>
  <p><strong>Decryption Example:</strong></p>
  <pre><code>cargo run -- decrypt -i secret.enc -o secret_decrypted.txt -p "YourStrongPassword"</code></pre>

  <h2>Future Enhancements</h2>
  <ul>
    <li>
      <strong>Streaming Support:</strong> Improve the tool to handle large files by processing data in chunks rather than loading the entire file into memory.
    </li>
    <li>
      <strong>Secure Password Input:</strong> Replace CLI password arguments with secure input methods using crates like <code>rpassword</code>.
    </li>
    <li>
      <strong>Memory Zeroing:</strong> Integrate the <code>zeroize</code> crate to clear sensitive data from memory once it is no longer needed.
    </li>
  </ul>

  <h2>Conclusion</h2>
  <p>
    The AES provides a robust and secure solution for encrypting and decrypting files using modern cryptographic standards in Rust. 
    With its clear file format and strong security considerations, it serves as a solid foundation for building more advanced secure file handling applications.
  </p>
</body>
</html>

